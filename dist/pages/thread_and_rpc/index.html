<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>MIT 6.824 - 2 ：多线程和RPC | charming</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/img/favicon.ico">
    <script data-ad-client="ca-pub-7828333725993554" async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <meta name="description" content="web前端技术博客,简洁至上,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github等技术文章。">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    <link rel="preload" href="/assets/css/0.styles.c3f8d04e.css" as="style"><link rel="preload" href="/assets/js/app.5e77cd93.js" as="script"><link rel="preload" href="/assets/js/2.82899674.js" as="script"><link rel="preload" href="/assets/js/17.c021c7a6.js" as="script"><link rel="prefetch" href="/assets/js/10.44cfcfdf.js"><link rel="prefetch" href="/assets/js/11.a5a10eff.js"><link rel="prefetch" href="/assets/js/12.d194756e.js"><link rel="prefetch" href="/assets/js/13.3aebd337.js"><link rel="prefetch" href="/assets/js/14.8423b279.js"><link rel="prefetch" href="/assets/js/15.54386d3e.js"><link rel="prefetch" href="/assets/js/16.db26bb12.js"><link rel="prefetch" href="/assets/js/18.ebf961b5.js"><link rel="prefetch" href="/assets/js/19.a2ae041b.js"><link rel="prefetch" href="/assets/js/20.4121614a.js"><link rel="prefetch" href="/assets/js/21.ca55f243.js"><link rel="prefetch" href="/assets/js/22.9d39abe5.js"><link rel="prefetch" href="/assets/js/3.2525e973.js"><link rel="prefetch" href="/assets/js/4.45fe6c92.js"><link rel="prefetch" href="/assets/js/5.91931b01.js"><link rel="prefetch" href="/assets/js/6.815bee85.js"><link rel="prefetch" href="/assets/js/7.8c59a895.js"><link rel="prefetch" href="/assets/js/8.87367026.js"><link rel="prefetch" href="/assets/js/9.504d153e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c3f8d04e.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/EB-logo.png" alt="charming" class="logo"> <span class="site-name can-hide">charming</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/head.jpeg"> <div class="blogger-info"><h3>charmingz</h3> <span>开心的码农</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>MIT 6.824 - 2 ：多线程和RPC</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/thread_and_rpc/#为什么是多线程" class="sidebar-link">为什么是多线程</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/thread_and_rpc/#线程的挑战" class="sidebar-link">线程的挑战</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/thread_and_rpc/#爬虫示例" class="sidebar-link">爬虫示例</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/thread_and_rpc/#什么是爬虫" class="sidebar-link">什么是爬虫</a></li><li class="sidebar-sub-header"><a href="/pages/thread_and_rpc/#挑战" class="sidebar-link">挑战</a></li><li class="sidebar-sub-header"><a href="/pages/thread_and_rpc/#实现" class="sidebar-link">实现</a></li></ul></li><li><a href="/pages/thread_and_rpc/#目标" class="sidebar-link">目标</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/thread_and_rpc/#软件结构" class="sidebar-link">软件结构</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/thread_and_rpc/#kv示例" class="sidebar-link">KV示例</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/thread_and_rpc/#主要实现" class="sidebar-link">主要实现</a></li><li class="sidebar-sub-header"><a href="/pages/thread_and_rpc/#一些细节" class="sidebar-link">一些细节</a></li><li class="sidebar-sub-header"><a href="/pages/thread_and_rpc/#异常处理" class="sidebar-link">异常处理</a></li></ul></li></ul></section></li></ul> <div class="sidebar-slot sidebar-slot-bottom"><!-- 正方形 -->
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="3508773082"
          data-ad-format="auto"
          data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div></aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-33863c7e><div class="articleInfo" data-v-33863c7e><!----> <div class="info" data-v-33863c7e><div title="作者" class="author iconfont icon-touxiang" data-v-33863c7e><a href="https://github.com/CharmingZhou" target="_blank" title="作者" class="beLink" data-v-33863c7e>charmingz</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-33863c7e><a href="javascript:;" data-v-33863c7e>2022-10-04</a></div> <div title="分类" class="date iconfont icon-wenjian" data-v-33863c7e><a href="/categories/?category=%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F" data-v-33863c7e>分布式系统 </a></div></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">
          MIT 6.824 - 2 ：多线程和RPC
        </h1> <div class="page-slot page-slot-top"><!-- 固定100% * 90px可显示，max-height:90px未见显示-->
     <ins class="adsbygoogle"
          style="display:inline-block;width:100%;max-height:90px"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="6625304284"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div> <div class="theme-vdoing-content content__default"><p align="center"><img src="/img/mit/2/bk.jpg" width="960" height="540"></p> <h1 id="为什么用go"><a href="#为什么用go" class="header-anchor">#</a> 为什么用Go</h1> <p><img src="/img/mit/2/go.png" alt="why go" title="go"></p> <ol><li>特别简单，仅有25个关键字，没 C++那么多复杂的语法特性</li> <li>超强并发能力，语言层面支持线程(goroutine)和管道(channel)</li> <li>类型安全，内存访问安全，很难写出像C++一样内存越界访问等bug</li> <li>垃圾回收，降低开发人员内存管理的心智负担</li></ol> <h1 id="多线程"><a href="#多线程" class="header-anchor">#</a> 多线程</h1> <p>线程是控制并发的重要手段，但处理可能比较棘手。Go中称它们为协程，其他的称它为线程。</p> <p>多线程允许一个程序同时做很多事情，每个线程都是串行执行的，就像普通的的非线程程序一样。每个线程可以有自己的内存栈、程序计数器、寄存器。但多个线程可以共享内存，也就是共享一个地址空间。</p> <h2 id="为什么是多线程"><a href="#为什么是多线程" class="header-anchor">#</a> 为什么是多线程</h2> <p>它们能够很好实现分布式系统所需要的并发性。</p> <p><strong>I/O并发</strong></p> <p>对于单核，IO可能是主要瓶颈，为了充分利用CPU，一个线程在进行IO时，可以让出CPU，让另一个线程进行计算、读取或发送网络消息等。服务端在处理客户端的多个请求时，每个请求都可能阻塞。比如X请求时从磁盘读取数据，Y请求往磁盘写数据。IO并发可以让可以多个请求不阻塞。</p> <p><strong>多核性能</strong></p> <p>充分利用多核CPU，在多个核上并行执行代码。</p> <p><strong>方便</strong></p> <p>在后台启动一个线程，定期执行某件事、周期性的检测worker是否存活。</p> <p><strong>QA</strong></p> <ol><li>是否有多线程的替代方案？基于事件驱动的异步编程，它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。事件驱动为带来了I/O并发性，并且消除了线程切换成本，但没有多核加速，另外编程会比较复杂，而多线程模型更容易理解一些，毕竟每个线程内执行顺序和代码顺序大体是一致的。</li></ol> <h2 id="线程的挑战"><a href="#线程的挑战" class="header-anchor">#</a> 线程的挑战</h2> <p><strong>竞态条件（数据共享）</strong></p> <p>共享数据容易出错。一个经典问题是，两个线程同时执行n=n+1，或者一个线程读取n，而另外一个线程在执行递增操作。由于该操作不是原子的，在不加锁时，n很可能不是预期的值。
我们称这种情况为竞态（race）：即两个以上的线程同时试图改变某个共享变量。
解决方法避免共享数据，或者加锁</p> <p><strong>多线程协调</strong></p> <p>一个线程正在生成数据，另一个正在消费，消费者如何等待（并释放CPU）? 生产者怎样才能唤醒消费者？</p> <ol><li>channel: go中比较推荐的方式，分阻塞和带缓冲</li> <li>sync.Cond：信号机制</li> <li>waitGroup：阻塞直到一组goroutine执行完毕</li></ol> <p><strong>死锁</strong></p> <p>产生条件：多个锁，循环依赖，占用并等待。
如果你的程序不干活了，但是又没死，那就要看看是否死锁了。</p> <h2 id="爬虫示例"><a href="#爬虫示例" class="header-anchor">#</a> 爬虫示例</h2> <h3 id="什么是爬虫"><a href="#什么是爬虫" class="header-anchor">#</a> 什么是爬虫</h3> <ol><li>从一个种子网页开始</li> <li>通过HTTP请求，获取其内容文本</li> <li>解析其内容包含的所有URL，针对所有URL重复进行2,3</li></ol> <h3 id="挑战"><a href="#挑战" class="header-anchor">#</a> 挑战</h3> <p>由于网页比较多，网络请求慢，一个接一个抓取时间太长。
利用I/O并发性：网络延时比网络容量更有限制，可以同时通过多线程并发获取多个URL来增加每秒获取URL个数。
每个URL只获取“一次”: 为了避免重复抓取导致的网络带宽资源浪费，对远端服务端更友好些，需要记住每个已经访问过的URL。
知道什么时候完成</p> <h3 id="实现"><a href="#实现" class="header-anchor">#</a> 实现</h3> <p>代码实现可以见：https://pdos.csail.mit.edu/6.824/notes/crawler.go</p> <h4 id="serial爬虫"><a href="#serial爬虫" class="header-anchor">#</a> Serial爬虫</h4> <p>深度优先遍历(DFS)全部网络构成的图结构，利用一个名为fetched的map（go中没有set）来保存所有已经抓取过的URL。</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">Serial</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">,</span> fetcher Fetcher<span class="token punctuation">,</span> fetched <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> fetched<span class="token punctuation">[</span>url<span class="token punctuation">]</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    fetched<span class="token punctuation">[</span>url<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
    urls<span class="token punctuation">,</span> err <span class="token operator">:=</span> fetcher<span class="token punctuation">.</span><span class="token function">Fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> u <span class="token operator">:=</span> <span class="token keyword">range</span> urls <span class="token punctuation">{</span>
        <span class="token function">Serial</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> fetcher<span class="token punctuation">,</span> fetched<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>我们是否可以在Serial()调用前添加一个&quot;go&quot;?会发生什么?</p> <h4 id="concurrentmutex爬虫"><a href="#concurrentmutex爬虫" class="header-anchor">#</a> ConcurrentMutex爬虫</h4> <ul><li>将抓取部分使用go关键字编程并行。但如果仅这么改造，不利于某些手段（sync.WaitGroup）等待子goroutine，而直接返回，那么可能只会抓取到种子URL，同时造成子goroutine的泄露。</li> <li>如果访问已经抓取的URL集合fetched不加锁，很可能造成多次拉取同一个网页</li></ul> <p><strong>为什么使用互斥锁Lock()和Unlock()?</strong></p> <ul><li>两个不同的网页包含了同一个URL连接，两个线程同时后去这两个页面，T1读取 fetched[url]，T2 读取 fetched[url]，两者都看到url还没有被获取 (already == false)，两者都取，这是错误的，加锁保证只有一个线程已经看到already==false</li> <li>map是一个复杂的数据结构，并发更新/更新可能会破坏内部不变量，并发更新/读取可能导致读取崩溃</li></ul> <p><strong>去掉锁</strong></p> <p>如果在更新map的时候去掉锁，运行结果可能是正确的，因为race其实很难检测。好在go提供了竞态分析工具来查找潜在含有竞态的地方: go run -race crawler.go
该工具没有做静态分析，而是在动态执行过程中观察、记录各个goroutine的执行轨迹，进行分析</p> <p><strong>等待执行完成</strong></p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">var</span> done sync<span class="token punctuation">.</span>WaitGroup
<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> u <span class="token operator">:=</span> <span class="token keyword">range</span> urls<span class="token punctuation">{</span>
    done<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>u <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">defer</span> done<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token function">ConcurrentMutex</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> fetcher<span class="token punctuation">,</span> f<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span> <span class="token comment">//u被拷贝</span>
<span class="token punctuation">}</span>
done<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>WaitGroup内部维护了一个计数器，调用wg.Add(n)时会增加n；调用wait.Done()时会减少1。这时调用wg.Wait()会一直阻塞直到当计数器变为0。所以WaitGroup很适合等待一组goroutine都结束的场景。</p> <h4 id="cocurrentchannel爬虫"><a href="#cocurrentchannel爬虫" class="header-anchor">#</a> CocurrentChannel爬虫</h4> <p>channel是go内置的通道，允许一个线程向另一个线程发送对象，发送方等待某个goroutine接收，接收者等待直到一些goroutine发送。channel既通信又同步，多个线程可以在一个通道上发送和接，channel是开销较低。
我们可以不使用锁+共享变量，而使用channel通信来实现并发的爬虫。具体做法类似实现一个生产消费者模型，使用channel做消息队列。</p> <ol><li>创建一个channel，用来接收种子URL</li> <li>消费者：master不断从channel中取出urls，判断是否抓取过，然后启动新的worker goroutine去抓取</li> <li>生产者：worker goroutine抓取到给定的任务URL，并将解析的结果urls放回channel</li> <li>master使用一个变量n来记录创建的任务数，创建一个任务增加1，从channel中获取并处理完毕一份结果减一，当所有任务处理完时，退出程序</li></ol> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">worker</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">,</span> ch <span class="token keyword">chan</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> fetcher Fetcher<span class="token punctuation">)</span><span class="token punctuation">{</span>
    urls<span class="token punctuation">,</span> err <span class="token operator">:=</span> fetcher<span class="token punctuation">.</span><span class="token function">Fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">{</span>
        ch <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        ch <span class="token operator">&lt;-</span> urls
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">master</span><span class="token punctuation">(</span>ch <span class="token keyword">chan</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> fetcher Fetcher<span class="token punctuation">)</span><span class="token punctuation">{</span>
    n <span class="token operator">:=</span> <span class="token number">1</span>
    fetched <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> urls <span class="token operator">:=</span> <span class="token keyword">range</span> ch<span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> u <span class="token operator">:=</span> <span class="token keyword">range</span> urls<span class="token punctuation">{</span>
            <span class="token keyword">if</span> fetched<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">{</span>
                fetched<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
                n <span class="token operator">+=</span> <span class="token number">1</span>
                <span class="token keyword">go</span> <span class="token function">worker</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> ch<span class="token punctuation">,</span> fetcher<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        n <span class="token operator">-=</span> <span class="token number">1</span>
        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">{</span>
            <span class="token keyword">break</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">ConcurrentChannel</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">,</span> fetcher Fetcher<span class="token punctuation">)</span><span class="token punctuation">{</span>
    ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        ch <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span>url<span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">master</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> fetcher<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p><strong>QA</strong></p> <ol><li>master读channel，多worker写channel，不会有竞争问题吗？channel是线程安全的。worker只在发送之前写slice，master只在接收后读取slice，因此它们不会在同一时刻使用slice。</li> <li>channel不需要最后close吗？ 我们使用n追踪了所有执行中的任务数，因此当n为0退出时，channel中不存在任何任务/结果，因此master/worker都不会对channel存在引用，gc collector会将其回收。</li> <li>为什么在ConcurrentChannel需要用goroutine往channel中写一个url? 如果不使用，master在读取的时候会一直阻塞，并且channel是一个非缓冲channel，如果不用goroutine，将会永远阻塞在写的时候。</li> <li>什么时候使用共享和锁，而不是通道？大多数问题都可以用两种方式解决，最重要取决于程序员如何思考，对于状态，通常使用数据共享和锁，对于通信，通常使用通道。</li></ol> <h1 id="rpc-远程过程调用"><a href="#rpc-远程过程调用" class="header-anchor">#</a> RPC（远程过程调用）</h1> <p>RPC是分布式系统中的一个关键部件，允许客户端通过RPC执行服务端的函数，就像调用本地函数一样。</p> <h2 id="目标"><a href="#目标" class="header-anchor">#</a> 目标</h2> <ol><li>容易编写客户端/服务端通信代码</li> <li>隐藏网络协议细节</li> <li>将数据（字符串、数组、map等）转换成统一格式(wire format)</li></ol> <h2 id="软件结构"><a href="#软件结构" class="header-anchor">#</a> 软件结构</h2> <p>client app        handler fns</p> <p>stub fns         dispatcher</p> <p>RPC lib           RPC lib</p> <p>net  ------------ net</p> <h2 id="kv示例"><a href="#kv示例" class="header-anchor">#</a> KV示例</h2> <p>使用Go RPC 库实现的一个key/value存储服务器，包含Put(key, value), Get(key)-&gt;value两个接口。</p> <h3 id="主要实现"><a href="#主要实现" class="header-anchor">#</a> 主要实现</h3> <p><strong>公共部分</strong></p> <p>为服务端每个handler声明Args和Reply结构体</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">type</span> Err <span class="token builtin">string</span>

<span class="token keyword">type</span> PutArgs <span class="token keyword">struct</span> <span class="token punctuation">{</span>
        Key   <span class="token builtin">string</span>
        Value <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> PutReply <span class="token keyword">struct</span> <span class="token punctuation">{</span>
        Err Err
<span class="token punctuation">}</span>

<span class="token keyword">type</span> GetArgs <span class="token keyword">struct</span> <span class="token punctuation">{</span>
        Key <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> GetReply <span class="token keyword">struct</span> <span class="token punctuation">{</span>
        Err   Err
        Value <span class="token builtin">string</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p><strong>客户端</strong></p> <ol><li>通过connect()的Dial()方法创建一个与服务端的TCP连接</li> <li>get()和put()是客户端“stubs”</li> <li>Call()会通过RPC库来执行调用</li> <li>指定服务端函数名、参数、放置应答的位置</li> <li>库将组装参数、发送请求、等待、解码应答</li> <li>从Call()返回一个值表示它是否得到一个应答</li> <li>收到reply.Err表示服务失败等级</li></ol> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">get</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
    client <span class="token operator">:=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    args <span class="token operator">:=</span> GetArgs<span class="token punctuation">{</span><span class="token string">&quot;subject&quot;</span><span class="token punctuation">}</span>
    reply <span class="token operator">:=</span> GetReply<span class="token punctuation">{</span><span class="token punctuation">}</span>
    err <span class="token operator">:=</span> client<span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span><span class="token string">&quot;KV.Get&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>args<span class="token punctuation">,</span> <span class="token operator">&amp;</span>reply<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">&quot;error:&quot;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    client<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> reply<span class="token punctuation">.</span>Value
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>服务端</strong></p> <ul><li>Go要求服务端声明一个对象，其中包含了用作RPC handlers的方法。</li> <li>服务端使用RPC库注册该对象</li> <li>服务端接收TCP连接，并将其分配给RPC库</li> <li>RPC库处理
<ul><li>读取每个请求</li> <li>为此请求创建一个新的goroutine</li> <li>解析请求</li> <li>查找命名对象（在由Register()创建的表中）</li> <li>调用对象的命名方法(dispatch)</li> <li>组包进行回复</li> <li>在TCP连接上写应答</li></ul></li> <li>服务端Get()和Put()处理：必须加锁，因为RPC库为每个请求创建一个新的goroutine，读取参数，修改应答</li></ul> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">server</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        kv <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>KV<span class="token punctuation">)</span>
        kv<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        rpcs <span class="token operator">:=</span> rpc<span class="token punctuation">.</span><span class="token function">NewServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        rpcs<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span>kv<span class="token punctuation">)</span>
        l<span class="token punctuation">,</span> e <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">&quot;tcp&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;127.0.0.1:1234&quot;</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> e <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
                log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">&quot;listen error:&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">{</span>
                        conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> l<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                        <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
                                <span class="token keyword">go</span> rpcs<span class="token punctuation">.</span><span class="token function">ServeConn</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                                <span class="token keyword">break</span>
                        <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                l<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>kv <span class="token operator">*</span>KV<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>args <span class="token operator">*</span>GetArgs<span class="token punctuation">,</span> reply <span class="token operator">*</span>GetReply<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
        kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">defer</span> kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

        val<span class="token punctuation">,</span> ok <span class="token operator">:=</span> kv<span class="token punctuation">.</span>data<span class="token punctuation">[</span>args<span class="token punctuation">.</span>Key<span class="token punctuation">]</span>
        <span class="token keyword">if</span> ok <span class="token punctuation">{</span>
                reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> OK
                reply<span class="token punctuation">.</span>Value <span class="token operator">=</span> val
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrNoKey
                reply<span class="token punctuation">.</span>Value <span class="token operator">=</span> <span class="token string">&quot;&quot;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>kv <span class="token operator">*</span>KV<span class="token punctuation">)</span> <span class="token function">Put</span><span class="token punctuation">(</span>args <span class="token operator">*</span>PutArgs<span class="token punctuation">,</span> reply <span class="token operator">*</span>PutReply<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
        kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">defer</span> kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

        kv<span class="token punctuation">.</span>data<span class="token punctuation">[</span>args<span class="token punctuation">.</span>Key<span class="token punctuation">]</span> <span class="token operator">=</span> args<span class="token punctuation">.</span>Value
        reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> OK
        <span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br></div></div><h3 id="一些细节"><a href="#一些细节" class="header-anchor">#</a> 一些细节</h3> <p><strong>绑定：</strong> 客户端如何知道要与哪台服务器计算机通信？</p> <ul><li>对于Go的RPC，服务器名字/端口是Dial的参数。</li> <li>对于大型系统通常有某种名称或配置服务器</li></ul> <p><strong>组包：</strong> 将数据格式化成数据包</p> <ul><li>Go的RPC库可以传递字符串、数组、对象、map等</li> <li>Go通过复制指向的数据来传递指针</li> <li>不能传递通道或函数</li></ul> <h3 id="异常处理"><a href="#异常处理" class="header-anchor">#</a> 异常处理</h3> <p>RPC问题：出错如何处理？比如：丢包、网络中断、服务器变慢、服务器宕机</p> <p>对于客户端RPC库来说，失败意味着什么？</p> <ul><li>客户端永远不会看到来自服务端的应答</li> <li>客户端不知道服务端是否看到了请求
<ul><li>服务端可能永远看不到请求</li> <li>服务端执行了，在发送应答前崩溃了</li> <li>服务端执行了，在发送回复前网络中断</li></ul></li></ul> <p>最简单的故障处理方案：“尽最大努力”</p> <ul><li>Call()等到响应一段时间</li> <li>如果没有响应，重新发送请求</li> <li>重试几次，然后放弃并返回错误</li></ul> <p>QA</p> <ol><li>应用程序是否容易处理“尽最大努力”？特别糟糕的解决方案：客户端执行了Put(&quot;k&quot;,10)和Put(&quot;k&quot;,20)都成功了，那Get(&quot;k&quot;)返回啥？
[图标，超时，重新发送，原始的到达晚了]</li> <li>尽最大努力可以吗？只读操作可以，重复执行不会做任何事情的操作，例如：DB检查记录是否已经插入。</li></ol> <p>更好的RPC行为：最多一次
思路：服务端RPC代码检测是否是重复请求，如果重复返回先前的结果，而不是重新执行handler逻辑。</p> <p>QA
如何检测重复请求？客户端包含每个请求的唯一ID(XID)，使用相同的XID重新发送</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code>    <span class="token comment">//server:</span>
    <span class="token keyword">if</span> seen<span class="token punctuation">[</span>xid<span class="token punctuation">]</span><span class="token punctuation">:</span>
      r <span class="token operator">=</span> old<span class="token punctuation">[</span>xid<span class="token punctuation">]</span>
    <span class="token keyword">else</span>
      r <span class="token operator">=</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      old<span class="token punctuation">[</span>xid<span class="token punctuation">]</span> <span class="token operator">=</span> r
      seen<span class="token punctuation">[</span>xid<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>至多一次的复杂性</p> <ul><li>如果两个客户端使用相同的XID怎么办？ 使用随机大数或者将唯一的客户端ID(ip地址)与序列号结合？</li> <li>服务端最终必须丢弃旧rpc信息，什么时候丢弃是安全的？
思路：每个客户端都有一个唯一的ID(可能是一个大的随机数)
每个客户端分配一个RPC序列号，客户端在每个RPC中包含“seen all replies &lt;=X” ，很像TCP序列化和ack。或者一次只允许客户端一个未完成的RPC，seq+1的到达允许服务端丢弃所有&lt;=seq的请求</li> <li>如何处理重复的请求，而原来仍在执行？
服务器还不知道应答
思路：每个执行RPC有个&quot;pending&quot;标志，等待或忽略</li></ul> <p>如果at-most-once服务端崩溃并重启该怎么办？</p> <ol><li>如果内存中最多重复一次信息，服务器将会忘记，并接受重复的请求后重新启动</li> <li>也许它应该将重复的信息写入磁盘</li> <li>也许复制服务端也应该复制重复的信息</li></ol> <p>Go RPC是一个简单的“at-most-once”形式</p> <ol><li>打开TCP连接</li> <li>写请求到TCP连接</li> <li>Go RPC从未重新发送请求，这样服务端就不会看到重复的请求</li> <li>如果没有得到回复，Go RPC代码将返回一个错误</li> <li>可能在超时之后（来之TCP）</li> <li>可能是服务端没有看到请求</li> <li>可能是服务端处理了请求，但是服务端/网络在回复返回之前失败了</li></ol> <p>怎么处理“恰好一次”？无限重试加上重复检测加上容错服务</p></div></div> <div class="page-slot page-slot-bottom"><!-- 横向自适应 -->
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="6620245489"
          data-ad-format="auto"
          data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/master/docs/_posts/分布式系统/MIT 6.824 - 2 ：多线程和RPC.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="tags"><a href="/tags/?tag=MIT" title="标签">#MIT</a><a href="/tags/?tag=%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F" title="标签">#分布式系统</a></div> <!----></div> <div class="page-nav-wapper"><!----> <!----></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/f2e63fblgt2/"><div>分布式系统常见设计模式</div></a> <span>10-01</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:965957185@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/CharmingZhou" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2022-2022
    <span>Evan Xu | <a href="https://github.com/xugaoyi/vuepress-theme-vdoing/blob/master/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">跟随系统</li><li class="iconfont icon-rijianmoshi">浅色模式</li><li class="iconfont icon-yejianmoshi">深色模式</li><li class="iconfont icon-yuedu">阅读模式</li></ul></div></div> <!----> <!----> <div class="custom-html-window custom-html-window-rb" style="display:;"><div class="custom-wrapper"><i class="close-but">×</i> <div><!-- 固定160*160px -->
      <ins class="adsbygoogle"
          style="display:inline-block;max-width:160px;max-height:160px"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="8377369658"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
      </div></div></div></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.5e77cd93.js" defer></script><script src="/assets/js/2.82899674.js" defer></script><script src="/assets/js/17.c021c7a6.js" defer></script>
  </body>
</html>